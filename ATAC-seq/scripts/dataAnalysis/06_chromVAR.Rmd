---
title: "chromVAR analysis"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    keep_md: true
    fig_width: 5
    fig_height: 5
    fig_caption: yes
    code_folding: hide
    toc: true
    toc_float: 
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(SummarizedExperiment)
library(limma)
library(chromVAR)
library(chromVARmotifs)
library(motifmatchr)
library(BSgenome.Mmusculus.UCSC.mm10)
library(BiocParallel)
library(ggpubr)
library(ggrepel)
library(RColorBrewer)
library(pheatmap)
library(circlize)
library(csaw)
library(org.Mm.eg.db)
library(TxDb.Mmusculus.UCSC.mm10.knownGene)

dir <- "/Users/ibarra01/OneDrive - CRUK Cambridge Institute/github/somitogenesis2020/"

## plot formatting
th <- theme_bw() + 
  theme(axis.text.x = element_text(size=10), 
        axis.title.x = element_text(size=12), 
        axis.text.y = element_text(size=10), 
        axis.title.y = element_text(size=12), 
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        axis.line = element_line(colour = "black"), 
        panel.border = element_blank(), 
        plot.title = element_text(face="bold", hjust = 0.5, size=12))

## colour palettes
cols.stage <- c("darkolivegreen4", "skyblue", "cornflowerblue", 
                "dodgerblue4", "darkorange", "indianred1")
names(cols.stage) <- paste0("stage", c(8,18,21,25,27,35))
cols.somite <- alpha(rep("orchid4",3),c(0.25, 0.5, 0.75))
names(cols.somite) <- paste0("S", c("I", "II", "III"))

## parallelisation options
register(SerialParam())
```

`chromVAR` is a method that exploits the aggregated signal from peaks containing a particular motif, k-mer or annotation, to uncover those that are correlated with variability in accessibility across samples. Since the method relies on identifying matches to motif models, and these occur by chance often, the size of the regions that are analysed is important. Thus, we will start from the window counts, instead of the peak counts, since peaks are of different sizes.

The windows we used for normalisation were 150 bp in length, sliding 50bp to cover the whole genome. We then filtered to retain only those with enough counts and overlapping peaks. Counts are then normalised and batch corrected as done previously.

```{r prepare_data, fig.width=5, fig.height=4}
## counts from 150 bp windows, that slide by 50 bp, along the whole genome
## filtered to retain only those overlapping peaks (as called by MACS2) and of certain abundance
windowCounts <- readRDS(paste0(dir, "ATAC-seq/results/03_windowCounts_filteredWindows.Rds"))
# add sample names
colnames(windowCounts) <- substr(windowCounts$bam.files, 83, nchar(windowCounts$bam.files)-14)

## add metadata
meta <- read.table(paste0(dir, "ATAC-seq/data/metadata_ATACseq_GQ.tsv"), header = TRUE)
# make stage and somite factors with correct levels
meta$somite <- factor(meta$somite, levels = paste0("S", c("III","II","I")))
meta$stage <- paste0("stage", meta$stage)
meta$stage <- factor(meta$stage, levels = paste0("stage", c(8,18,21,25,27,35)))

stopifnot(identical(meta$sample, colnames(windowCounts)))
colData(windowCounts) <- cbind(colData(windowCounts), meta[,c(3:6)])
## remove unwanted columns
colData(windowCounts) <- colData(windowCounts)[,c(2,5:8)]

## chromVar expects the total library size in a column named 'depth'
colnames(colData(windowCounts))[1] <- "depth"
## add GC content information
windowCounts <- addGCBias(windowCounts, genome = BSgenome.Mmusculus.UCSC.mm10)


## add normalised counts, by using the `offsets` to do trended normalisation
# offsets are in natural log scale; convert everything to log2
offsets <- assay(windowCounts, "offset")
assay(windowCounts, 'normalised') <- log2(assay(windowCounts)+0.5) - offsets/log(2)


## regress out batch effects
# PCs for correction 
pcs <- read.table(paste0(dir, "ATAC-seq/results/03_pcs_residuals.tab"))

# design matrix
meta$group <- factor(paste(meta$stage, meta$somite, sep="."))
design <- model.matrix(~0+group, meta)
colnames(design) <- paste0("stage",levels(meta$group))

## regress out PCs
normCounts <- assay(windowCounts, 'normalised')
normCounts.corr <- removeBatchEffect(normCounts, 
                                     design = design,
                                     covariates = pcs[,1:18])
## assign to windowCounts and save for later use
assay(windowCounts, 'corrected') <- normCounts.corr
saveRDS(windowCounts, paste0(dir, "ATAC-seq/results/06_windowCounts_filteredWindows_normCorr.Rds"))

## compute PCA for visualisation later on
vars <- rowVars(normCounts.corr)
tmp <- normCounts.corr[order(vars, decreasing=TRUE)[1:5000],]
pca <- prcomp(t(tmp))
pca <- as.data.frame(pca$x)
pca <- cbind(pca, meta[match(row.names(pca), meta$sample),])

ggplot(pca, aes(PC1, PC2, colour=stage)) +
  geom_point() +
  scale_color_manual(values = cols.stage) +
  th
```

```{r collect_data, echo=FALSE}
## assign corrected counts to `counts` to use with chromVAR
# and convert to linear scale
counts <- windowCounts
counts(counts) <- 2^assay(counts, 'corrected')

## remove objects no longer needed to free memory
rm(normCounts)
rm(normCounts.corr)
rm(windowCounts)
gc(verbose = FALSE)
```

We start by computing deviation scores for mouse transcription factor (TF) motifs provided in the `chromVARmotifs` package that includes a non-redundant collection curated from [cisBP](http://cisbp.ccbr.utoronto.ca/). 

```{r compute_deviations}
# filter overlapping windows; the most abundant is retained
counts_filtered <- filterPeaks(counts, non_overlapping = TRUE)

# match which peaks contain each motif
data("mouse_pwms_v2") # mouse collection from cisBP; non-redundant
motif_ix <- matchMotifs(mouse_pwms_v2, counts_filtered, 
                        genome = BSgenome.Mmusculus.UCSC.mm10)

# compute deviation scores
dev <- computeDeviations(object = counts_filtered, annotations = motif_ix)
# deviation scores are very highly correlated if using only normalised data
# scores between raw and normalised data are almost identical
# proceed with batch-corrected for consistency with the rest of the analyses
```


Based on the deviation scores, we can compute the pairwise correlations between samples. Samples tend to cluster by stage, although segregation isn't perfect.

```{r sample_correlation, fig.width=7, fig.height=5}
## sample correlation based on deviation scores
sample_cor <- getSampleCorrelation(dev)

pheatmap(as.dist(sample_cor),
         annotation_col = as.data.frame(colData(dev)[,c(1,3,4)]),
         clustering_distance_rows = as.dist(1-sample_cor), 
         clustering_distance_cols = as.dist(1-sample_cor))
```

Next, we compute the variability for each TF across samples. There are many TFs with large variability, and these might have important functions regulating somite differentiation and development.

```{r variability}
## variability for each motif across samples
variability <- computeVariability(dev)
# plot(density(variability$variability))

variability[order(variability$variability, decreasing = TRUE),][1:10,]
```
We can use PCA to visualise the samples based on their accessibility data; and then overlay the deviation scores for variable TFs. For example, Esrra, one of the top scoring TFs, is very well correlated with somite stage, suggesting that sites bound by this family of TFs increase in accessibility as development progresses.

```{r plot_stage, fig.width=6, fig.height=4}
palette <- colorRamp2(breaks = c(-1,0,1), colors = c("steelblue3","white", "indianred3"))

## plot TF z-scores on PCA
tf <- "Esrra"
i <- grep(tf, row.names(dev))
df <- cbind(pca, z=assay(dev, 'z')[i,])

plots <- list()
plots[[1]] <- ggplot(df, aes(PC1, PC2, colour=stage)) +
  geom_point() +
  scale_color_manual(values = cols.stage) +
  th
plots[[2]] <- ggplot(df, aes(PC1, PC2)) +
  geom_point(aes(fill=z), colour="grey50", pch=21) +
  scale_fill_gradientn(colours = palette(seq(-1,1,0.1))) +
  ggtitle(tf) +
  th
ggarrange(plotlist = plots, ncol=2, nrow=1, legend = "bottom", align = "h")
```

Other TFs show variability between the somite trios, although there are many fewer instances of these.

```{r plot_somite, fig.width=6, fig.height=6}
## plot TF z-scores on PCA
tf <- "Cdx2"
i <- grep(tf, row.names(dev))
df <- cbind(pca, z=assay(dev, 'z')[i,])

plots <- list()
plots[[1]] <- ggplot(df, aes(PC1, PC2, colour=stage)) +
  geom_point() +
  scale_color_manual(values = cols.stage) +
  th
plots[[2]] <- ggplot(df, aes(PC1, PC2)) +
  geom_point(aes(fill=z), colour="grey50", pch=21) +
  scale_fill_gradientn(colours = palette(seq(-1,1,0.1))) +
  ggtitle(tf) +
  th
plots[[3]] <- ggplot(df, aes(stage, z, colour=stage)) +
  geom_boxplot() +
  scale_color_manual(values = cols.stage) +
  ggtitle(tf) +
  th
plots[[4]] <- ggplot(df, aes(stage, z, colour=somite)) +
  geom_boxplot() +
  scale_color_manual(values = cols.somite) +
  ggtitle(tf) +
  th
ggarrange(plotlist = plots, ncol=2, nrow=2, legend = "none", align = "h")
```

To better identify TFs that vary with respect to our groups of interest, we directly test for differences in deviation scores between somites and stages.

```{r diff_deviation}
## determine if there is a significant difference between deviation scores among groups
diff_acc.somite <- differentialDeviations(dev, "somite")
diff_acc.somite <- diff_acc.somite[order(diff_acc.somite$p_value_adjusted),]
# diff_acc.somite[diff_acc.somite$p_value_adjusted<0.05,]

diff_acc.stage <- differentialDeviations(dev, "stage")
diff_acc.stage <- diff_acc.stage[order(diff_acc.stage$p_value_adjusted),]
# diff_acc.stage[diff_acc.stage$p_value_adjusted < 0.05,]
```

In total, `r sum(diff_acc.somite$p_value_adjusted<0.05)` TFs are significantly different between the somite trios, and `r sum(diff_acc.stage$p_value_adjusted<0.05)` between stages.

```{r eval=FALSE, include=FALSE, fig.height=8}
dat <- assay(dev, 'z')[row.names(diff_acc.stage[diff_acc.stage$p_value_adjusted<0.01,]),]
order <- order(meta$stage, meta$somite)
ha  <- ComplexHeatmap::HeatmapAnnotation(df = data.frame(stage = meta[order,]$stage, 
                                                         somite = meta[order,]$somite), 
                                         col = list(stage = cols.stage, somite = cols.somite))

ComplexHeatmap::Heatmap(dat[,order], 
        cluster_columns = FALSE, 
        col=colorRamp2(breaks = c(-15,0,10,15),
                       colors = c("steelblue","white", "indianred3", "indianred4")),
        name = "z-score", 
        show_row_names = FALSE, 
        show_column_names = FALSE, 
        top_annotation = ha,
        km = 12)
```

#### Cooperative binding

By looking at the difference in variability in accessibility between sites with pairs of TFs, versus when these occur alone, can suggest cooperative/competitive binding. We look at this *additional variability* present when both proteins bind together for the Hox proteins and their reported cofactors: Pbx1-4, Meis1-3 and Prep1-2 (Pknox1-2). Some patterns are evident but nothing particularly clear between Hox proteins and their cofactors, perhaps because these often occur in tripartite complexes, not just as heterodimers.

```{r synergy, fig.width=10, fig.height=10}
select <- c(grep("Hox", colnames(motif_ix)),
            grep("Pbx", colnames(motif_ix)),
            grep("Meis", colnames(motif_ix)),
            grep("Pknox", colnames(motif_ix)))

synergy_hox <- getAnnotationSynergy(counts_filtered, motif_ix[,select])
row.names(synergy_hox) <- unlist(lapply(strsplit(row.names(synergy_hox),"_"), '[[', 3))
colnames(synergy_hox) <- unlist(lapply(strsplit(colnames(synergy_hox),"_"), '[[', 3))

pheatmap(synergy_hox, breaks = seq(-5, 5, length.out=101))

correlation_hox <- getAnnotationCorrelation(counts_filtered, motif_ix[,select])
row.names(correlation_hox) <- unlist(lapply(strsplit(row.names(correlation_hox),"_"), '[[', 3))
colnames(correlation_hox) <- unlist(lapply(strsplit(colnames(correlation_hox),"_"), '[[', 3))
# pheatmap(correlation_hox)
```

#### Hox genes

Below are the deviation scores for all Hox genes across stages.

```{r plot_hox, fig.width=10, fig.height=8}
## plot TF z-scores on PCA
plots <- list()
for(hox in grep("Hox", row.names(variability), value = TRUE)){
  i <- grep(hox, row.names(dev))
  df <- cbind(pca, z=assay(dev, 'z')[i,])
  
  plots[[hox]] <- ggplot(df, aes(stage, z, colour=stage)) +
    geom_boxplot() +
    scale_color_manual(values = cols.stage) +
    ggtitle(unlist(strsplit(hox, "_"))[3]) +
    th
}

idx <- grep("Hoxa",names(plots))
idx <- idx[c(4,3,11,2,9,10,8,7,1,6,5)]
ggarrange(plotlist = plots[idx], ncol=4, nrow=3, legend = "none", align = "hv")
idx <- grep("Hoxb",names(plots))
idx <- idx[c(2,10,7,4,5,1,6,9,3,8)]
ggarrange(plotlist = plots[idx], ncol=4, nrow=3, legend = "none", align = "hv")
idx <- grep("Hoxc",names(plots))
idx <- idx[c(9,6,4,3,7,5,2,8,1)]
ggarrange(plotlist = plots[idx], ncol=4, nrow=3, legend = "none", align = "hv")
idx <- grep("Hoxd",names(plots))
idx <- idx[c(4,9,5,3,7,8,6,2,1)]
ggarrange(plotlist = plots[idx], ncol=4, nrow=3, legend = "none", align = "hv")
```


### PBM-HOMEO motif collection

A study by [Berger et al. Cell, 2008](https://doi.org/10.1016/j.cell.2008.05.024) profiled the binding affinity of mouse homeodomain TFs by using microarrays containing all possible 10nt sequences. Although binding doesn't occur under physiological conditions, and no cofactors are available, these data represent a well-controlled assay to define sequence affinity for each TF, including all Hox proteins.

We can use these motifs instead of the cisBP collection used above. In this case, results will be limited only to homeodomain TFs, but these play many important roles during development and somitogenesis. Based on the deviation scores, samples cluster by both stage and somite.

```{r homeo, fig.width=7, fig.height=5}
homeo <- getJasparMotifs(species = "Mus musculus", collection = "PBM_HOMEO")
homeo_ix <- matchMotifs(homeo, counts_filtered, 
                        genome = BSgenome.Mmusculus.UCSC.mm10)

# compute deviation scores
dev_homeo <- computeDeviations(object = counts_filtered, annotations = homeo_ix)

# sample correaltion
sample_cor_homeo <- getSampleCorrelation(dev_homeo)
pheatmap(as.dist(sample_cor_homeo),
         annotation_col = as.data.frame(colData(dev_homeo)[,c(1,3,4)]),
         clustering_distance_rows = as.dist(1-sample_cor_homeo), 
         clustering_distance_cols = as.dist(1-sample_cor_homeo))
```

And in terms of variability in accessibility deviations, late Hox proteins show much higher variation compared to mid or early Hox members, or other homeodomain TFs. This is driven by the unique accessibility of these Hox genes in the stage35 samples. 

Cdx1 and Cdx2 are also very highly ranked, perhaps due to their consistent variation across somite trios.

```{r variability_homoe, warning=FALSE, message=FALSE, fig.width=7, fig.height=4}
## variability for each motif across samples
variability_homeo <- computeVariability(dev_homeo)
variability_homeo <- variability_homeo[order(variability_homeo$variability, decreasing = TRUE),]

## plot
variability_homeo$Hox <- ifelse(grepl("Hox", variability_homeo$name), "Hox", "non-Hox")
variability_homeo$label <- ifelse(variability_homeo$variability > 3.5, variability_homeo$name, "")

ggplot(variability_homeo, aes(1:nrow(variability_homeo), variability, colour=Hox, label=label)) +
  geom_point() +
  scale_color_manual(values = c('Hox'="indianred3", 'non-Hox'="grey60")) +
  geom_text_repel(show.legend=FALSE) +
  xlab("homeodomain TFs") +
  labs(colour="") +
  th + theme(axis.text.x = element_blank(),
             axis.ticks.x = element_blank())
```

The picture for these TFs when using the cisBP motif database is pretty similar, with the main differences being:

- Hoxc9, Hoxc10 and Hoxd11 are more variable when using the homeodomain-specific motifs.
- Hoxc8 and Hoxd8 are more variable with the cisBP motifs.

```{r compare, warning=FALSE, fig.width=10, fig.height=5}
## compare variability estimates with the two sets of motifs
# same plot with the cisBP data
tmp <- variability[variability$name %in% variability_homeo$name,]
tmp <- tmp[order(tmp$variability, decreasing=TRUE),]
tmp$label <- ifelse(tmp$variability>4, tmp$name, "")
tmp$Hox <- ifelse(grepl("Hox", tmp$name), "Hox", "non-Hox")

plots <- list()
plots[[1]] <- ggplot(tmp, aes(1:nrow(tmp), variability, colour=Hox, label=label)) +
  geom_point() +
  scale_color_manual(values = c('Hox'="indianred3", 'non-Hox'="grey60")) +
  geom_text_repel(size=4, show.legend=FALSE, max.overlaps = 50) +
  ggtitle("using cisBP motifs") +
  xlab("homeodomain TFs") +
  labs(colour="") +
  th + theme(axis.text.x = element_blank(),
             axis.ticks.x = element_blank(),
             legend.position = "none")

# direct comparison
tfs <- intersect(tmp$name, variability_homeo$name)
tmp <- data.frame(tf = tfs, 
                  cisBP = variability[match(tfs, variability$name),]$variability,
                  homeo = variability_homeo[match(tfs, variability_homeo$name),]$variability)
plots[[2]] <- ggplot(tmp, aes(cisBP, homeo, label=tf)) +
  geom_point() +
  geom_text_repel() +
  ggtitle("variability across motif databases") +
  # geom_abline(slope = 1, intercept = 0, col="grey60", lty=2) +
  th
ggarrange(plotlist = plots, ncol=2, align = "hv")
```

### K-mer analysis

Repeating the analysis using k-mers instead of motif PWMs returns similar results. The most variable k-mers correspond to the motifs identified before.

```{r kmer_deviations, fig.width=7, fig.height=4}
kmer_ix <- matchKmers(8, counts_filtered, genome = BSgenome.Mmusculus.UCSC.mm10)
dev_kmer <- computeDeviations(counts_filtered, kmer_ix)

# kmer_cov <- deviationsCovariability(kmer_dev)
# plotKmerMismatch("CTAATTCA", kmer_cov)

variability_kmer <- computeVariability(dev_kmer)
variability_kmer <- variability_kmer[order(variability_kmer$variability, decreasing = TRUE),]
variability_kmer$label <- ifelse(variability_kmer$variability > 7.5, variability_kmer$name, "")

ggplot(variability_kmer, aes(1:nrow(variability_kmer), variability, label=label)) +
  geom_point() +
  geom_text_repel(size=3, max.overlaps = 100, show.legend=FALSE) +
  xlab("k-mers (k=8)") +
  labs(colour="") +
  geom_hline(yintercept = 1.5, lty=2) +
  th + theme(axis.text.x = element_blank(),
             axis.ticks.x = element_blank())
```

```{r plot_kmer, fig.width=6, fig.height=6}
## plot TF z-scores on PCA
tf <- "CATCAATC"
i <- grep(tf, row.names(dev_kmer))
df <- cbind(pca, z=assay(dev_kmer, 'z')[i,])

plots <- list()
plots[[1]] <- ggplot(df, aes(PC1, PC2, colour=stage)) +
  geom_point() +
  scale_color_manual(values = cols.stage) +
  th
plots[[2]] <- ggplot(df, aes(PC1, PC2)) +
  geom_point(aes(fill=z), colour="grey50", pch=21) +
  scale_fill_gradientn(colours = palette(seq(-1,1,0.1))) +
  ggtitle(tf) +
  th
plots[[3]] <- ggplot(df, aes(stage, z, colour=stage)) +
  geom_boxplot() +
  scale_color_manual(values = cols.stage) +
  ggtitle(tf) +
  th
plots[[4]] <- ggplot(df, aes(stage, z, colour=somite)) +
  geom_boxplot() +
  scale_color_manual(values = cols.somite) +
  ggtitle(tf) +
  th
ggarrange(plotlist = plots, ncol=2, nrow=2, legend = "none", align = "h")
```

However, the scores for specific k-mers could be useful later on.

```{r eval=FALSE, include=FALSE, fig.height=12, fig.width=10}
props <- list()
par(mfrow=c(6,6), mar=c(2,2,2,2))
for(hox in grep("Hox", row.names(variability), value = TRUE)){
  ## get windows with predicted TFBS
  wins_with_hox <- which(assay(motif_ix[,hox]))
  ## get k-mers for that set of windows; look at the most abundant
  props[[hox]] <- colSums(assay(kmer_ix[wins_with_hox,]))/length(wins_with_hox)*100
  plot(props[[hox]][order(props[[hox]], decreasing = TRUE)], main=hox, xlab="", ylab="")
  legend("topright", legend = paste("n>5 =", sum(props[[hox]]>=5)))
}

hox_kmers <- unlist(sapply(names(props), function(x) names(props[[x]][props[[x]]>5])))
tmp <- table(hox_kmers)
tmp[order(tmp, decreasing = TRUE)]

dat <- assay(dev_kmer, 'z')[unique(hox_kmers),]
pheatmap(dat,
         show_colnames = FALSE,
         fontsize_row = 7,
         annotation_col = as.data.frame(colData(dev_kmer)[,c(1,3,4)]),
         breaks=seq(-7, 7, length.out=101))
```


### Signal by chromosomal location instead of TF motifs

Another way of finding loci that are variable across samples is to look at the accessibility signal for windows across the genome, based on chromosomal location. With this approach, sets of 25 windows are grouped as the *regions of interest* and deviation and variability scores are computed. The range slides down by 10 windows, to cover the whole genome.

A very large number of regions capture variability across samples; some of the top hits are, not surprisingly, loci containing Hox genes from late paralogue groups, which are only accessible in stage35.

```{r chr_loc, fig.width=7, fig.height=4}
# match which peaks are in each chromosomal window
cis_ix <- getCisGroups(counts_filtered, grpsize = 25, stepsize = 10) 

# compute deviation scores
dev_chr <- computeDeviations(object = counts_filtered, annotations = cis_ix)

# variability per TF
variability_chr <- computeVariability(dev_chr)
variability_chr <- variability_chr[order(variability_chr$variability, decreasing = TRUE),]
variability_chr$label <- ifelse(variability_chr$variability>7, variability_chr$name, "")

ggplot(variability_chr, aes(1:nrow(variability_chr), variability, label=label)) +
  geom_point() +
  geom_text_repel(size=3, max.overlaps = 100) +
  xlab("transcription factors") +
  labs(colour="") +
  th + theme(axis.text.x = element_blank(),
             axis.ticks.x = element_blank())
```

And the correlation between deviation profiles separates samples by stage well, although the thoracic samples mix somewhat.

```{r chr_correlation, fig.width=7, fig.height=5}
# correlation between samples
sample_cor_chr <- getSampleCorrelation(dev_chr)
pheatmap(as.dist(sample_cor_chr),
         annotation_col = as.data.frame(colData(dev_chr)[,c(3,4)]),
         clustering_distance_rows = as.dist(1-sample_cor_chr), 
         clustering_distance_cols = as.dist(1-sample_cor_chr))
```

As before, we can test for differential deviation scores between somite trios and between stages. This results in over 2K regions between somite trios and nearly 30K between stages.

```{r diff_deviation_cis}
## determine if there is a significant difference between deviation scores among groups
diff_acc.chrLoc.somite <- differentialDeviations(dev_chr, "somite")
diff_acc.chrLoc.somite <- diff_acc.chrLoc.somite[order(diff_acc.chrLoc.somite$p_value_adjusted),]
# diff_acc.chrLoc.somite[diff_acc.chrLoc.somite$p_value_adjusted<0.05,]

diff_acc.chrLoc.stage <- differentialDeviations(dev_chr, "stage")
diff_acc.chrLoc.stage <- diff_acc.chrLoc.stage[order(diff_acc.chrLoc.stage$p_value_adjusted),]
# diff_acc.chrLoc.stage[diff_acc.chrLoc.stage$p_value_adjusted < 0.05,]

## annotate loci
# restrict to most significant hits
# somite trios
diff_acc.chrLoc.somite.diff <- diff_acc.chrLoc.somite[diff_acc.chrLoc.somite$p_value_adjusted < 0.05,]
diff_acc.chrLoc.somite.diff$region <- row.names(diff_acc.chrLoc.somite.diff)
# convert to genomic ranges
diff_acc.chrLoc.somite.diff.gr <- t(apply(diff_acc.chrLoc.somite.diff, 1, function(x){
  windows <- rowRanges(cis_ix)[which(assay(cis_ix[,x[3]]))]
  c(chr = as.character(unique(seqnames(windows))), start=min(start(windows)), end=max(end(windows)),
    fdr = x[2])
}))
diff_acc.chrLoc.somite.diff.gr <- GRanges(diff_acc.chrLoc.somite.diff.gr[,1],
                                          IRanges(as.numeric(diff_acc.chrLoc.somite.diff.gr[,2]), 
                                                  as.numeric(diff_acc.chrLoc.somite.diff.gr[,3])),
                                          region = row.names(diff_acc.chrLoc.somite.diff.gr),
                                          FDR = diff_acc.chrLoc.somite.diff.gr[,4])
# annotate
mcols(diff_acc.chrLoc.somite.diff.gr) <- cbind(mcols(diff_acc.chrLoc.somite.diff.gr),
                                               detailRanges(diff_acc.chrLoc.somite.diff.gr, 
                                                            txdb=TxDb.Mmusculus.UCSC.mm10.knownGene,
                                                            orgdb=org.Mm.eg.db, 
                                                            promoter=c(0, 0), dist=0))

# stages
diff_acc.chrLoc.stage.diff <- diff_acc.chrLoc.stage[diff_acc.chrLoc.stage$p_value_adjusted < 0.05,]
diff_acc.chrLoc.stage.diff$region <- row.names(diff_acc.chrLoc.stage.diff)
# convert to genomic ranges
diff_acc.chrLoc.stage.diff.gr <- t(apply(diff_acc.chrLoc.stage.diff, 1, function(x){
  windows <- rowRanges(cis_ix)[which(assay(cis_ix[,x[3]]))]
  c(chr = as.character(unique(seqnames(windows))), start=min(start(windows)), end=max(end(windows)),
    fdr = x[2])
}))
diff_acc.chrLoc.stage.diff.gr <- GRanges(diff_acc.chrLoc.stage.diff.gr[,1],
                                          IRanges(as.numeric(diff_acc.chrLoc.stage.diff.gr[,2]), 
                                                  as.numeric(diff_acc.chrLoc.stage.diff.gr[,3])),
                                          region = row.names(diff_acc.chrLoc.stage.diff.gr),
                                          FDR = diff_acc.chrLoc.stage.diff.gr[,4])
# annotate
mcols(diff_acc.chrLoc.stage.diff.gr) <- cbind(mcols(diff_acc.chrLoc.stage.diff.gr),
                                              detailRanges(diff_acc.chrLoc.stage.diff.gr, 
                                                           txdb=TxDb.Mmusculus.UCSC.mm10.knownGene,
                                                           orgdb=org.Mm.eg.db, 
                                                           promoter=c(0, 0), dist=0))
```

These deviation scores based on genomic location will be useful to infer the accessibility landscape across samples for particular genes.


```{r save}
saveRDS(counts_filtered, paste0(dir, "ATAC-seq/results/06_windowsFilteredCHROMVAR_counts_norm_14PCs.Rds"))

## cisBP motifs
saveRDS(motif_ix, paste0(dir, "ATAC-seq/results/06_motif_matches.Rds"))
saveRDS(dev, paste0(dir, "ATAC-seq/results/06_motif_deviationScores.Rds"))
write.table(variability, paste0(dir, "ATAC-seq/results/06_motif_variability.tsv"),
            quote = FALSE, sep="\t")
write.table(diff_acc.somite, paste0(dir, "ATAC-seq/results/06_motif_diffAcc_somiteTrios.tsv"),
            quote = FALSE, sep="\t")
write.table(diff_acc.stage, paste0(dir, "ATAC-seq/results/06_motif_diffAcc_stages.tsv"),
            quote = FALSE, sep="\t")
saveRDS(synergy_hox, paste0(dir, "ATAC-seq/results/06_motif_synergyScores.Rds"))
saveRDS(correlation_hox, paste0(dir, "ATAC-seq/results/06_motif_correlationScores.Rds"))

## k-mers
saveRDS(kmer_ix, paste0(dir, "ATAC-seq/results/06_8kmer_matches.Rds"))
saveRDS(dev_kmer, paste0(dir, "ATAC-seq/results/06_8kmer_deviationScores.Rds"))
write.table(variability_kmer, paste0(dir, "ATAC-seq/results/06_8kmer_variability.tsv"),
            quote = FALSE, sep="\t")

## chromosomal location
saveRDS(cis_ix, paste0(dir, "ATAC-seq/results/06_chrLocation_matches.Rds"))
saveRDS(dev_chr, paste0(dir, "ATAC-seq/results/06_chrLocation_deviationScores.Rds"))
write.table(variability_chr, paste0(dir, "ATAC-seq/results/06_chrLocation_variability.tsv"),
            quote = FALSE, sep="\t")
saveRDS(diff_acc.chrLoc.somite.diff.gr, 
        paste0(dir, "ATAC-seq/results/06_chrLocation_diffAcc_somiteTrios.Rds"))
saveRDS(diff_acc.chrLoc.stage.diff.gr, 
        paste0(dir, "ATAC-seq/results/06_chrLocation_diffAcc_stages.Rds"))
```


```{r info}
sessionInfo()
```

